<!doctype html>
<html lang="el">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Î•Î½Î·Î¼ÎµÏÏ‰Ï„Î¹ÎºÎ® Ï†ÏŒÏÎ¼Î±</title>
  <style>
    :root {
      --bg: #0f172a;          /* slate-900 */
      --panel: #111827;       /* gray-900 */
      --muted: #94a3b8;       /* slate-400 */
      --text: #e5e7eb;        /* gray-200 */
      --brand: #22c55e;       /* green-500 */
      --danger: #ef4444;      /* red-500 */
      --border: #1f2937;      /* gray-800 */
      --card: #0b1220;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: radial-gradient(1200px 800px at 80% -20%, #1e293b, #0b1220 55%), var(--bg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: var(--text); line-height: 1.5;
      display: grid; place-items: center; padding: 24px;
    }
    .card {
      width: min(920px, 100%);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid var(--border);
      border-radius: 20px; padding: 28px; box-shadow: 0 10px 40px rgba(0,0,0,0.35);
      backdrop-filter: blur(8px);
    }
    h1 { margin: 0 0 10px; font-weight: 700; letter-spacing: .2px; }
    p { color: var(--muted); }

    .field { margin: 18px 0; }
    .label { font-size: 14px; color: var(--muted); margin-bottom: 8px; display: block; }
    .input {
      width: 100%; padding: 14px 16px; background: var(--panel); color: var(--text);
      border: 1px solid var(--border); border-radius: 12px; outline: none;
      transition: border-color .2s, box-shadow .2s;
    }
    .input:focus { border-color: #334155; box-shadow: 0 0 0 4px rgba(59,130,246,.15); }

    .status { font-size: 13px; margin-top: 6px; min-height: 18px; }
    .ok { color: var(--brand); }
    .err { color: var(--danger); }

    .sig-wrap {
      border: 1px dashed #334155; border-radius: 12px; background: #0b1220; padding: 12px;
    }
    .sig-toolbar { display:flex; gap:8px; align-items:center; margin-bottom:8px; }
    .sig-toolbar button, .sig-toolbar select, .sig-toolbar input[type="range"] {
      appearance: none; background: var(--panel); color: var(--text); border: 1px solid var(--border);
      border-radius: 10px; padding: 8px 12px; cursor: pointer; font-size: 13px;
    }
    .sig-toolbar input[type="range"]{ width:160px; cursor: ew-resize; padding: 8px 0; }
    .sig-canvas {
      width: 100%; height: 220px; background: #0a0f1c; border: 1px solid var(--border); border-radius: 10px;
      touch-action: none; /* Pointer events for touch */
      display:block;
    }

    .audio-box { border: 1px dashed #334155; border-radius: 12px; background: #0b1220; padding: 12px; }
    .audio-controls { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
    .audio-controls button { appearance:none; background: var(--panel); color: var(--text); border:1px solid var(--border); border-radius:10px; padding:8px 12px; cursor:pointer; font-size:13px; }
    audio { width: 100%; display:block; margin-top: 8px; }
    .badge { font-size: 11px; padding: 2px 6px; border: 1px solid var(--border); border-radius: 999px; color: #cbd5e1; }

    .actions { display:flex; flex-wrap:wrap; gap:10px; justify-content:flex-end; margin-top: 20px; }
    .btn {
      padding: 12px 16px; border-radius: 12px; border: 1px solid var(--border); cursor: pointer; font-weight: 600;
      background: var(--panel); color: var(--text);
    }
    .btn.primary { background: linear-gradient(180deg, #16a34a, #15803d); border-color: #14532d; }
    .btn[disabled] { opacity:.6; cursor:not-allowed; }

    .note { font-size: 12px; color: var(--muted); }
    .footer { display:flex; align-items:center; gap:10px; justify-content:space-between; margin-top: 8px; }

    .toast { margin-top:12px; padding:10px 12px; border-radius:10px; font-size:14px; display:none; }
    .toast.show { display:block; }
    .toast.success { background:#052e1b; border:1px solid #14532d; color:#b9f5d0; }
    .toast.error { background:#3b0a0a; border:1px solid #7f1d1d; color:#fecaca; }

    code { background:#0b1220; padding: 2px 6px; border-radius:6px; border: 1px solid var(--border); }
  </style>
</head>
<body>
  <main class="card" role="main">
    <h1>Î•Î½Î·Î¼ÎµÏÏ‰Ï„Î¹ÎºÏŒ</h1>
    <p>
      Î Î±ÏÎ±ÎºÎ±Î»Ï Î´Î¹Î±Î²Î¬ÏƒÏ„Îµ Ï„Î¿ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ ÎµÎ½Î·Î¼ÎµÏÏ‰Ï„Î¹ÎºÏŒ ÎºÎµÎ¯Î¼ÎµÎ½Î¿ ÎºÎ±Î¹ ÎµÏ€Î¹Î²ÎµÎ²Î±Î¹ÏÏƒÏ„Îµ
      ÏŒÏ„Î¹ ÏƒÏ…Î¼Ï†Ï‰Î½ÎµÎ¯Ï„Îµ Î³ÏÎ¬Ï†Î¿Î½Ï„Î±Ï‚ <strong>Î±Ï…ÏƒÏ„Î·ÏÎ¬</strong> Ï„Î·Î½ Î±ÎºÏÎ¹Î²Î® Ï†ÏÎ¬ÏƒÎ·
      <code>ÎœÎ¬Î»Î¹ÏƒÏ„Î± ÏŒ,Ï„Î¹ Ï€ÎµÎ¯Ï„Îµ</code>, Ï…Ï€Î¿Î³ÏÎ¬ÏˆÏ„Îµ ÏƒÏ„Î¿ Ï€Î»Î±Î¯ÏƒÎ¹Î¿ ÎºÎ±Î¹ Î·Ï‡Î¿Î³ÏÎ±Ï†Î®ÏƒÏ„Îµ
      Ï†Ï‰Î½Î·Ï„Î¹ÎºÏŒ ÏŒÏ€Î¿Ï… Î»Î­Ï„Îµ Î±ÎºÏÎ¹Î²ÏÏ‚ Ï„Î·Î½ Î¯Î´Î¹Î± Ï†ÏÎ¬ÏƒÎ·.
    </p>

    <form id="consentForm" autocomplete="off">
      <section class="field">
        <label class="label" for="infoText">Î•Î½Î·Î¼ÎµÏÏ‰Ï„Î¹ÎºÏŒ ÎºÎµÎ¯Î¼ÎµÎ½Î¿</label>
        <div id="infoText" class="input" style="min-height:120px; white-space:pre-wrap;">
Î¤Î¿ Ï€Î±ÏÏŒÎ½ Î±Ï€Î¿Ï„ÎµÎ»ÎµÎ¯ ÎµÎ½Î´ÎµÎ¹ÎºÏ„Î¹ÎºÏŒ ÎµÎ½Î·Î¼ÎµÏÏ‰Ï„Î¹ÎºÏŒ ÎºÎµÎ¯Î¼ÎµÎ½Î¿. Î”Î·Î»ÏÎ½Ï‰ ÏŒÏ„Î¹ Î­Î»Î±Î²Î± Î³Î½ÏÏƒÎ· ÎºÎ±Î¹ Î±Ï€Î¿Î´Î­Ï‡Î¿Î¼Î±Î¹ Ï„Î¿Ï…Ï‚ ÏŒÏÎ¿Ï…Ï‚ ÏŒÏ€Ï‰Ï‚ Ï€ÎµÏÎ¹Î³ÏÎ¬Ï†Î¿Î½Ï„Î±Î¹ ÎµÎ´Ï.
        </div>
        <div class="note">Î¤Î¿ ÎºÎµÎ¯Î¼ÎµÎ½Î¿ ÎµÎ¯Î½Î±Î¹ ÎµÎ½Î´ÎµÎ¹ÎºÏ„Î¹ÎºÏŒ â€” Ï€ÏÎ¿ÏƒÎ±ÏÎ¼ÏŒÏƒÏ„Îµ Ï„Î¿ ÏŒÏ€Ï‰Ï‚ Î¸Î­Î»ÎµÏ„Îµ.</div>
      </section>

      <!-- Î¥Ï€Î¿Î³ÏÎ±Ï†Î® -->
      <section class="field">
        <label class="label">Î¥Ï€Î¿Î³ÏÎ±Ï†Î® Î¼Îµ Ï„Î¿ Î´Î¬Ï‡Ï„Ï…Î»Î¿/Ï€Î¿Î½Ï„Î¯ÎºÎ¹</label>
        <div class="sig-wrap">
          <div class="sig-toolbar">
            <button type="button" id="clearSig">ÎšÎ±Î¸Î±ÏÎ¹ÏƒÎ¼ÏŒÏ‚</button>
            <label class="note">Î Î¬Ï‡Î¿Ï‚ Î³ÏÎ±Î¼Î¼Î®Ï‚: <input id="stroke" type="range" min="1" max="8" value="3"></label>
          </div>
          <canvas id="sig" class="sig-canvas" aria-label="Î ÎµÏÎ¹Î¿Ï‡Î® Ï…Ï€Î¿Î³ÏÎ±Ï†Î®Ï‚"></canvas>
        </div>
        <div class="footer">
          <span class="note">Î¥Ï€ÏŒÎ´ÎµÎ¹Î¾Î·: Î¥Ï€ÏŒÎ³ÏÎ±ÏˆÎµ ÏƒÏ„Î¿ Ï€Î»Î±Î¯ÏƒÎ¹Î¿. Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¯Î·ÏƒÎµ Ï„Î¿ ÎºÎ¿Ï…Î¼Ï€Î¯ ÎºÎ±Î¸Î±ÏÎ¹ÏƒÎ¼Î¿Ï Î±Î½ Ï‡ÏÎµÎ¹Î±ÏƒÏ„ÎµÎ¯.</span>
          <span id="sigStatus" class="status"></span>
        </div>
      </section>

      <!-- Î¦Ï‰Î½Î·Ï„Î¹ÎºÏŒ (Î±Î½Î¬Î¼ÎµÏƒÎ± Î±Ï€ÏŒ Ï…Ï€Î¿Î³ÏÎ±Ï†Î® ÎºÎ±Î¹ Î³ÏÎ±Ï€Ï„Î® Ï†ÏÎ¬ÏƒÎ·) -->
      <section class="field">
        <label class="label">Î¦Ï‰Î½Î·Ï„Î¹ÎºÏŒ Î¼Îµ Ï„Î· Ï†ÏÎ¬ÏƒÎ· <span id="envBadge" class="badge"></span></label>
        <div class="audio-box">
          <div class="audio-controls">
            <button type="button" id="recBtn">ğŸ”´ ÎˆÎ½Î±ÏÎ¾Î· Î·Ï‡Î¿Î³ÏÎ¬Ï†Î·ÏƒÎ·Ï‚</button>
            <button type="button" id="stopBtn" disabled>â¹ï¸ Î”Î¹Î±ÎºÎ¿Ï€Î®</button>
            <span id="recStatus" class="status"></span>
          </div>
          <audio id="audioPreview" controls></audio>
          <div class="note">Î ÎµÏ‚ ÎºÎ±Î¸Î±ÏÎ¬: <code>ÎœÎ¬Î»Î¹ÏƒÏ„Î± ÏŒ,Ï„Î¹ Ï€ÎµÎ¯Ï„Îµ</code>. Î£Îµ Instagram/iPhone Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹ fallback ÏƒÎµ WAV Î³Î¹Î± Î¼Î­Î³Î¹ÏƒÏ„Î· ÏƒÏ…Î¼Î²Î±Ï„ÏŒÏ„Î·Ï„Î±.</div>
        </div>
      </section>

      <!-- Î“ÏÎ±Ï€Ï„Î® Ï†ÏÎ¬ÏƒÎ· -->
      <section class="field">
        <label class="label" for="phrase">Î Î»Î·ÎºÏ„ÏÎ¿Î»ÏŒÎ³Î·ÏƒÎµ Î±ÎºÏÎ¹Î²ÏÏ‚ Ï„Î·Î½ Ï†ÏÎ¬ÏƒÎ·</label>
        <input id="phrase" class="input" placeholder="ÎœÎ¬Î»Î¹ÏƒÏ„Î± ÏŒ,Ï„Î¹ Ï€ÎµÎ¯Ï„Îµ" inputmode="text" />
        <div id="phraseStatus" class="status"></div>
      </section>

      <div class="actions">
        <button type="button" class="btn" id="previewBtn">Î ÏÎ¿ÎµÏ€Î¹ÏƒÎºÏŒÏ€Î·ÏƒÎ· Ï…Ï€Î¿Î³ÏÎ±Ï†Î®Ï‚</button>
        <button type="submit" class="btn primary" id="submitBtn" disabled>Î¥Ï€Î¿Î²Î¿Î»Î® â†’ Telegram</button>
      </div>
      <div id="toast" class="toast" role="status" aria-live="polite"></div>
    </form>

    <p class="note" style="margin-top:18px">
      <strong>Î ÏÎ¿ÎµÎ¹Î´Î¿Ï€Î¿Î¯Î·ÏƒÎ·:</strong> Î¤Î¿ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ Ï…Î»Î¿Ï€Î¿Î¹ÎµÎ¯ <u>Î¬Î¼ÎµÏƒÎ·</u> Î±Ï€Î¿ÏƒÏ„Î¿Î»Î® ÏƒÏ„Î¿ Telegram Bot API Î±Ï€ÏŒ Ï„Î¿Î½ browser Î¼Îµ Ï„Î¿ token <em>ÎµÎ½ÏƒÏ‰Î¼Î±Ï„Ï‰Î¼Î­Î½Î¿</em> ÏƒÏ„Î¿Î½ ÎºÏÎ´Î¹ÎºÎ±. Î•Î¯Î½Î±Î¹ Î¼Î·-Î±ÏƒÏ†Î±Î»Î­Ï‚ ÎºÎ±Î¹ ÎµÎ½Î´Î­Ï‡ÎµÏ„Î±Î¹ Î½Î± Î±Ï€Î¿Ï„ÏÏ‡ÎµÎ¹ Î»ÏŒÎ³Ï‰ CORS ÏƒÎµ Î¿ÏÎ¹ÏƒÎ¼Î­Î½Î± webviews. Î£Ï…Î½ÎµÏ‡Î¯Î¶ÎµÎ¹Ï‚ Î¼Îµ Î´Î¹ÎºÎ® ÏƒÎ¿Ï… ÎµÏ…Î¸ÏÎ½Î·.
    </p>
  </main>

  <script>
    // ======================== Î¡Î¥Î˜ÎœÎ™Î£Î•Î™Î£ (Î§Î¥ÎœÎ‘) ========================
    const TELEGRAM_BOT_TOKEN = "7932574102:AAFQvlNoBw2AWpRuHO7DWlBnRWyA1DhOGuE"; // Ï€.Ï‡. 123456:ABC...
    const TELEGRAM_CHAT_ID   = "7336951445";    // Ï€.Ï‡. 123456789

    const API = (method) => `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/${method}`;
    const REQUIRED_PHRASE = "ÎœÎ¬Î»Î¹ÏƒÏ„Î± ÏŒ,Ï„Î¹ Ï€ÎµÎ¯Ï„Îµ"; // Î±ÎºÏÎ¹Î²Î®Ï‚ Ï†ÏÎ¬ÏƒÎ· ÏƒÎµ NFC

    // Î ÎµÏÎ¹Î²Î¬Î»Î»Î¿Î½ (Instagram / iOS Î±Î½Î¯Ï‡Î½ÎµÏ…ÏƒÎ·)
    const UA = navigator.userAgent || '';
    const isInstagram = /Instagram/i.test(UA);
    const isFacebookApp = /(FBAN|FBAV)/i.test(UA);
    const isIOS = /iPhone|iPad|iPod/i.test(UA);

    const $ = sel => document.querySelector(sel);
    const envBadge = $('#envBadge');
    envBadge.textContent = [isInstagram? 'Instagram' : (isFacebookApp? 'Facebook App' : 'Browser'), isIOS? 'iOS' : ''].filter(Boolean).join(' Â· ');

    // ======================== DOM refs ========================
    const phraseEl = $('#phrase');
    const phraseStatus = $('#phraseStatus');
    const sigCanvas = $('#sig');
    const clearBtn = $('#clearSig');
    const strokeRange = $('#stroke');
    const sigStatus = $('#sigStatus');
    const form = $('#consentForm');
    const submitBtn = $('#submitBtn');
    const previewBtn = $('#previewBtn');
    const toast = $('#toast');

    const recBtn = $('#recBtn');
    const stopBtn = $('#stopBtn');
    const recStatus = $('#recStatus');
    const audioPreview = $('#audioPreview');

    // ======================== Î¥Ï€Î¿Î³ÏÎ±Ï†Î® (canvas) ========================
    let ctx, drawing = false, hasInk = false;
    let strokeWidth = parseInt(strokeRange.value, 10) || 3;

    function resizeCanvas() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = sigCanvas.getBoundingClientRect();
      sigCanvas.width = Math.floor(rect.width * dpr);
      sigCanvas.height = Math.floor(220 * dpr);
      ctx = sigCanvas.getContext('2d');
      ctx.scale(dpr, dpr);
      ctx.lineCap = 'round'; ctx.lineJoin = 'round';
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = strokeWidth;
      ctx.fillStyle = '#0a0f1c';
      ctx.fillRect(0,0, sigCanvas.width, sigCanvas.height);
    }

    function pointerPos(e){
      const rect = sigCanvas.getBoundingClientRect();
      const x = (e.clientX ?? e.touches?.[0]?.clientX) - rect.left;
      const y = (e.clientY ?? e.touches?.[0]?.clientY) - rect.top;
      return {x, y};
    }
    function startDraw(e){ e.preventDefault(); drawing = true; hasInk = true; updateSigStatus(); const {x,y} = pointerPos(e); ctx.beginPath(); ctx.moveTo(x, y); }
    function moveDraw(e){ if(!drawing) return; e.preventDefault(); const {x,y} = pointerPos(e); ctx.lineTo(x,y); ctx.stroke(); }
    function endDraw(){ drawing = false; }
    function clearSig(){ const rect = sigCanvas.getBoundingClientRect(); ctx.fillStyle = '#0a0f1c'; ctx.fillRect(0,0, rect.width, rect.height); ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = strokeWidth; hasInk = false; updateSigStatus(); maybeToggleSubmit(); }
    function updateSigStatus(){ sigStatus.textContent = hasInk ? 'Î¥Ï€Î¿Î³ÏÎ±Ï†Î® ÎºÎ±Ï„Î±Î³ÎµÎ³ÏÎ±Î¼Î¼Î­Î½Î·.' : 'Î”ÎµÎ½ Î­Ï‡ÎµÎ¹ Ï€ÏÎ¿ÏƒÏ„ÎµÎ¸ÎµÎ¯ Ï…Ï€Î¿Î³ÏÎ±Ï†Î®.'; sigStatus.className = 'status ' + (hasInk ? 'ok' : 'err'); }

    window.addEventListener('resize', resizeCanvas); resizeCanvas(); updateSigStatus();
    sigCanvas.addEventListener('pointerdown', startDraw);
    sigCanvas.addEventListener('pointermove', moveDraw);
    window.addEventListener('pointerup', endDraw);
    clearBtn.addEventListener('click', clearSig);
    strokeRange.addEventListener('input', e=>{ strokeWidth = parseInt(e.target.value,10)||3; ctx.lineWidth = strokeWidth; });

    // ======================== Î“ÏÎ±Ï€Ï„Î® Î¦ÏÎ¬ÏƒÎ· ========================
    function normalize(s){ return (s || '').normalize('NFC'); }
    function phraseIsValid(){ return normalize(phraseEl.value.trim()) === REQUIRED_PHRASE; }
    function updatePhraseStatus(){
      if(!phraseEl.value) { phraseStatus.textContent = ''; phraseStatus.className = 'status'; return; }
      if(phraseIsValid()) { phraseStatus.textContent = 'ÎŸÎš â€” Î· Ï†ÏÎ¬ÏƒÎ· ÎµÎ¯Î½Î±Î¹ Î±ÎºÏÎ¹Î²Î®Ï‚.'; phraseStatus.className = 'status ok'; }
      else { phraseStatus.textContent = 'Î ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎµÎ¯Î½Î±Î¹ Î±ÎºÏÎ¹Î²ÏÏ‚: "' + REQUIRED_PHRASE + '"'; phraseStatus.className = 'status err'; }
      maybeToggleSubmit();
    }
    phraseEl.addEventListener('input', updatePhraseStatus);

    // ======================== Î—Ï‡Î¿Î³ÏÎ¬Ï†Î·ÏƒÎ· (MediaRecorder Î® WAV fallback) ========================
    let mediaRecorder, chunks = [], audioBlob = null, audioMime = '';
    let wavRecorder = null; // fallback Î±Î½Ï„Î¹ÎºÎµÎ¯Î¼ÎµÎ½Î¿

    function chooseMime(){
      const prefer = [ 'audio/ogg; codecs=opus', 'audio/webm; codecs=opus', 'audio/webm' ];
      for(const t of prefer){ try{ if(window.MediaRecorder && MediaRecorder.isTypeSupported(t)) return t; }catch(_){} }
      return '';
    }

    function wavEncoder(buffers, sampleRate){
      // buffers: array of Float32Array (mono)
      const length = buffers.reduce((a,b)=>a+b.length,0);
      const wavBuffer = new ArrayBuffer(44 + length*2);
      const view = new DataView(wavBuffer);
      function writeStr(off, str){ for(let i=0;i<str.length;i++) view.setUint8(off+i, str.charCodeAt(i)); }
      let offset = 0;
      writeStr(0, 'RIFF'); view.setUint32(4, 36 + length*2, true); writeStr(8, 'WAVE');
      writeStr(12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true); // PCM
      view.setUint16(22, 1, true); // mono
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate*2, true); // byte rate
      view.setUint16(32, 2, true); // block align
      view.setUint16(34, 16, true); // bits per sample
      writeStr(36, 'data'); view.setUint32(40, length*2, true);
      offset = 44;
      for(const buf of buffers){
        for(let i=0;i<buf.length;i++){
          let s = Math.max(-1, Math.min(1, buf[i]));
          view.setInt16(offset, s < 0 ? s*0x8000 : s*0x7FFF, true);
          offset += 2;
        }
      }
      return new Blob([view], { type: 'audio/wav' });
    }

    function createWavFallback(stream){
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const source = ctx.createMediaStreamSource(stream);
      const processor = ctx.createScriptProcessor(4096, 1, 1);
      const chunks = [];
      source.connect(processor); processor.connect(ctx.destination);
      processor.onaudioprocess = e => { const ch = e.inputBuffer.getChannelData(0); chunks.push(new Float32Array(ch)); };
      return {
        stop: async () => { processor.disconnect(); source.disconnect(); const sr = ctx.sampleRate; const blob = wavEncoder(chunks, sr); try{ await ctx.close(); }catch(_){} return blob; },
        release: () => { try{ ctx.close(); }catch(_){} }
      };
    }

    async function startRecording(){
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true } });
        const type = chooseMime();
        if(window.MediaRecorder && type){
          mediaRecorder = new MediaRecorder(stream, {mimeType:type});
          chunks = []; audioBlob = null; audioMime = mediaRecorder.mimeType || type;
          mediaRecorder.ondataavailable = e => { if(e.data && e.data.size>0) chunks.push(e.data); };
          mediaRecorder.onstop = () => {
            audioBlob = new Blob(chunks, { type: audioMime });
            audioPreview.src = URL.createObjectURL(audioBlob);
            recStatus.textContent = audioBlob ? `ÎˆÏ„Î¿Î¹Î¼Î¿ Î·Ï‡Î·Ï„Î¹ÎºÏŒ (${Math.round(audioBlob.size/1024)} KB, ${audioMime})` : 'Î§Ï‰ÏÎ¯Ï‚ Î·Ï‡Î¿Î³ÏÎ¬Ï†Î·ÏƒÎ·';
            recStatus.className = 'status ' + (audioBlob ? 'ok' : 'err');
            maybeToggleSubmit();
            stream.getTracks().forEach(t=>t.stop());
          };
          mediaRecorder.start();
          recStatus.textContent = 'Î—Ï‡Î¿Î³ÏÎ¬Ï†Î·ÏƒÎ·â€¦ Ï€ÎµÏ‚: Â«'+REQUIRED_PHRASE+'Â»'; recStatus.className = 'status';
        } else {
          // Fallback Î³Î¹Î± Instagram WebView / iOS ÏŒÏ€Î¿Ï… MediaRecorder Î»ÎµÎ¯Ï€ÎµÎ¹
          wavRecorder = createWavFallback(stream);
          recStatus.textContent = 'Î—Ï‡Î¿Î³ÏÎ¬Ï†Î·ÏƒÎ· (WAV fallback)â€¦ Ï€ÎµÏ‚: Â«'+REQUIRED_PHRASE+'Â»';
          // Î˜Î± ÏƒÏ„Î±Î¼Î±Ï„Î®ÏƒÎ¿Ï…Î¼Îµ ÏŒÏ„Î±Î½ Ï€Î±Ï„Î·Î¸ÎµÎ¯ Stop, ÎµÎºÎµÎ¯ ÎºÎ¬Î½Î¿Ï…Î¼Îµ encode ÏƒÎµ WAV
        }
        recBtn.disabled = true; stopBtn.disabled = false;
      } catch (err) {
        console.error(err);
        recStatus.textContent = 'Î”ÎµÎ½ Î´ÏŒÎ¸Î·ÎºÎµ Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ· ÏƒÏ„Î¿ Î¼Î¹ÎºÏÏŒÏ†Ï‰Î½Î¿ Î® Î´ÎµÎ½ Ï…Ï€Î¿ÏƒÏ„Î·ÏÎ¯Î¶ÎµÏ„Î±Î¹ ÏƒÏ„Î¿ Ï€ÎµÏÎ¹Î²Î¬Î»Î»Î¿Î½.'; recStatus.className = 'status err';
      }
    }

    async function stopRecording(){
      try{
        if(mediaRecorder && mediaRecorder.state!=='inactive'){
          mediaRecorder.stop();
        } else if(wavRecorder){
          audioBlob = await wavRecorder.stop();
          audioMime = 'audio/wav';
          audioPreview.src = URL.createObjectURL(audioBlob);
          recStatus.textContent = `ÎˆÏ„Î¿Î¹Î¼Î¿ Î·Ï‡Î·Ï„Î¹ÎºÏŒ (${Math.round(audioBlob.size/1024)} KB, WAV)`;
          recStatus.className = 'status ok';
        }
      } finally {
        recBtn.disabled = false; stopBtn.disabled = true; wavRecorder = null;
        maybeToggleSubmit();
      }
    }

    recBtn.addEventListener('click', startRecording, { passive: true });
    stopBtn.addEventListener('click', stopRecording, { passive: true });

    // ======================== Î’Î¿Î·Î¸Î·Ï„Î¹ÎºÎ¬ ========================
    function showToast(msg, type='success'){ toast.textContent = msg; toast.className = 'toast show ' + (type==='success'?'success':'error'); }
    function dataUrlToBlob(dataUrl){ const [meta, base64] = dataUrl.split(','); const mime = /data:(.*?);base64/.exec(meta)?.[1] || 'image/png'; const bin = atob(base64); const len = bin.length; const bytes = new Uint8Array(len); for(let i=0;i<len;i++) bytes[i] = bin.charCodeAt(i); return new Blob([bytes], {type: mime}); }
    function maybeToggleSubmit(){ submitBtn.disabled = !(phraseIsValid() && hasInk && !!audioBlob); }

    // ======================== Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î­Ï‚ Ï€ÏÎ¿Ï‚ Telegram ========================
    async function tgSendMessage(text){
      const body = new URLSearchParams({ chat_id: TELEGRAM_CHAT_ID, text });
      return fetch(API('sendMessage'), { method: 'POST', body });
    }
    async function tgSendPhoto(file){
      const fd = new FormData();
      fd.append('chat_id', TELEGRAM_CHAT_ID);
      fd.append('caption', 'Î¥Ï€Î¿Î³ÏÎ±Ï†Î®');
      fd.append('photo', file, 'signature.png');
      return fetch(API('sendPhoto'), { method: 'POST', body: fd });
    }
    async function tgSendVoiceOrDoc(file){
      // Î‘Î½ ÎµÎ¯Î½Î±Î¹ OGG/Opus -> voice, Î±Î»Î»Î¹ÏÏ‚ WAV/WEBM ÏƒÎ±Î½ document
      const isOggOpus = file.type.startsWith('audio/ogg');
      const fd = new FormData();
      fd.append('chat_id', TELEGRAM_CHAT_ID);
      if(isOggOpus){
        fd.append('voice', file, 'voice.ogg');
        fd.append('caption', 'Î¦Ï‰Î½Î·Ï„Î¹ÎºÏŒ: "'+REQUIRED_PHRASE+'"');
        return fetch(API('sendVoice'), { method: 'POST', body: fd });
      } else {
        const name = file.type === 'audio/wav' ? 'voice.wav' : 'voice.webm';
        fd.append('document', file, name);
        fd.append('caption', 'Î—Ï‡Î·Ï„Î¹ÎºÏŒ Î¼Îµ Ï„Î· Ï†ÏÎ¬ÏƒÎ·');
        return fetch(API('sendDocument'), { method: 'POST', body: fd });
      }
    }

    // Î ÏÎ¿ÎµÏ€Î¹ÏƒÎºÏŒÏ€Î·ÏƒÎ· Ï…Ï€Î¿Î³ÏÎ±Ï†Î®Ï‚
    previewBtn.addEventListener('click', ()=>{
      const url = sigCanvas.toDataURL('image/png');
      const w = window.open('about:blank','_blank');
      w.document.write('<img alt="Î¥Ï€Î¿Î³ÏÎ±Ï†Î®" src="'+url+'" style="max-width:100%" />');
    });

    // Î¥Ï€Î¿Î²Î¿Î»Î® â€” Î£ÎµÎ¹ÏÎ¬: Photo (Ï…Ï€Î¿Î³ÏÎ±Ï†Î®) â†’ Voice/Doc (Ï†Ï‰Î½Î·Ï„Î¹ÎºÏŒ) â†’ Message (Î³ÏÎ±Ï€Ï„Î® Ï†ÏÎ¬ÏƒÎ·)
    form.addEventListener('submit', async (e)=>{
      e.preventDefault();
      if(!(phraseIsValid() && hasInk && audioBlob)) return;

      submitBtn.disabled = true; submitBtn.textContent = 'Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î®â€¦'; showToast('', 'success');
      try{
        const dataUrl = sigCanvas.toDataURL('image/png');
        const sigBlob = dataUrlToBlob(dataUrl);
        await tgSendPhoto(sigBlob);
        await tgSendVoiceOrDoc(audioBlob);
        await tgSendMessage('Î¦ÏÎ¬ÏƒÎ· ÎµÏ€Î¹Î²ÎµÎ²Î±Î¯Ï‰ÏƒÎ·Ï‚: '+REQUIRED_PHRASE);
        showToast('Î•ÏƒÏ„Î¬Î»Î·ÏƒÎ±Î½: Ï…Ï€Î¿Î³ÏÎ±Ï†Î®, Ï†Ï‰Î½Î·Ï„Î¹ÎºÏŒ, Ï†ÏÎ¬ÏƒÎ·. Î£Îµ webviews Î¯ÏƒÏ‰Ï‚ Î´ÎµÎ½ Î»Î·Ï†Î¸ÎµÎ¯ ÎµÏ€Î¹Î²ÎµÎ²Î±Î¯Ï‰ÏƒÎ· Î»ÏŒÎ³Ï‰ CORS.', 'success');
        submitBtn.textContent = 'Î¥Ï€Î¿Î²Î¿Î»Î® âœ”';
      }catch(err){
        console.error(err);
        showToast('Î£Ï†Î¬Î»Î¼Î± ÎºÎ±Ï„Î¬ Ï„Î·Î½ Î±Ï€Î¿ÏƒÏ„Î¿Î»Î® (Ï€Î¹Î¸Î±Î½ÏŒ CORS Î® Î´Î¯ÎºÏ„Ï…Î¿).', 'error');
        submitBtn.textContent = 'Î¥Ï€Î¿Î²Î¿Î»Î® Î¾Î±Î½Î¬';
        submitBtn.disabled = false;
      }
    });
  </script>
</body>
</html>
