<!doctype html>
<html lang="el">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ενημερωτική φόρμα</title>
  <style>
    :root {
      --bg: #0f172a;          /* slate-900 */
      --panel: #111827;       /* gray-900 */
      --muted: #94a3b8;       /* slate-400 */
      --text: #e5e7eb;        /* gray-200 */
      --brand: #22c55e;       /* green-500 */
      --danger: #ef4444;      /* red-500 */
      --border: #1f2937;      /* gray-800 */
      --card: #0b1220;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: radial-gradient(1200px 800px at 80% -20%, #1e293b, #0b1220 55%), var(--bg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: var(--text); line-height: 1.5;
      display: grid; place-items: center; padding: 24px;
    }
    .card {
      width: min(920px, 100%);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid var(--border);
      border-radius: 20px; padding: 28px; box-shadow: 0 10px 40px rgba(0,0,0,0.35);
      backdrop-filter: blur(8px);
    }
    h1 { margin: 0 0 10px; font-weight: 700; letter-spacing: .2px; }
    p { color: var(--muted); }

    .field { margin: 18px 0; }
    .label { font-size: 14px; color: var(--muted); margin-bottom: 8px; display: block; }
    .input {
      width: 100%; padding: 14px 16px; background: var(--panel); color: var(--text);
      border: 1px solid var(--border); border-radius: 12px; outline: none;
      transition: border-color .2s, box-shadow .2s;
    }
    .input:focus { border-color: #334155; box-shadow: 0 0 0 4px rgba(59,130,246,.15); }

    .status { font-size: 13px; margin-top: 6px; min-height: 18px; }
    .ok { color: var(--brand); }
    .err { color: var(--danger); }

    .sig-wrap {
      border: 1px dashed #334155; border-radius: 12px; background: #0b1220; padding: 12px;
    }
    .sig-toolbar { display:flex; gap:8px; align-items:center; margin-bottom:8px; }
    .sig-toolbar button, .sig-toolbar select, .sig-toolbar input[type="range"] {
      appearance: none; background: var(--panel); color: var(--text); border: 1px solid var(--border);
      border-radius: 10px; padding: 8px 12px; cursor: pointer; font-size: 13px;
    }
    .sig-toolbar input[type="range"]{ width:160px; cursor: ew-resize; padding: 8px 0; }
    .sig-canvas {
      width: 100%; height: 220px; background: #0a0f1c; border: 1px solid var(--border); border-radius: 10px;
      touch-action: none; /* Pointer events for touch */
      display:block;
    }

    .audio-box { border: 1px dashed #334155; border-radius: 12px; background: #0b1220; padding: 12px; }
    .audio-controls { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
    .audio-controls button { appearance:none; background: var(--panel); color: var(--text); border:1px solid var(--border); border-radius:10px; padding:8px 12px; cursor:pointer; font-size:13px; }
    audio { width: 100%; display:block; margin-top: 8px; }
    .badge { font-size: 11px; padding: 2px 6px; border: 1px solid var(--border); border-radius: 999px; color: #cbd5e1; }

    .actions { display:flex; flex-wrap:wrap; gap:10px; justify-content:flex-end; margin-top: 20px; }
    .btn {
      padding: 12px 16px; border-radius: 12px; border: 1px solid var(--border); cursor: pointer; font-weight: 600;
      background: var(--panel); color: var(--text);
    }
    .btn.primary { background: linear-gradient(180deg, #16a34a, #15803d); border-color: #14532d; }
    .btn[disabled] { opacity:.6; cursor:not-allowed; }

    .note { font-size: 12px; color: var(--muted); }
    .footer { display:flex; align-items:center; gap:10px; justify-content:space-between; margin-top: 8px; }

    .toast { margin-top:12px; padding:10px 12px; border-radius:10px; font-size:14px; display:none; }
    .toast.show { display:block; }
    .toast.success { background:#052e1b; border:1px solid #14532d; color:#b9f5d0; }
    .toast.error { background:#3b0a0a; border:1px solid #7f1d1d; color:#fecaca; }

    code { background:#0b1220; padding: 2px 6px; border-radius:6px; border: 1px solid var(--border); }
  </style>
</head>
<body>
  <main class="card" role="main">
    <h1>Ενημερωτικό</h1>
    <p>
      Παρακαλώ διαβάστε το παρακάτω ενημερωτικό κείμενο και επιβεβαιώστε
      ότι συμφωνείτε γράφοντας <strong>αυστηρά</strong> την ακριβή φράση
      <code>Μάλιστα ό,τι πείτε</code>, υπογράψτε στο πλαίσιο και ηχογραφήστε
      φωνητικό όπου λέτε ακριβώς την ίδια φράση.
    </p>

    <form id="consentForm" autocomplete="off">
      <section class="field">
        <label class="label" for="infoText">Ενημερωτικό κείμενο</label>
        <div id="infoText" class="input" style="min-height:120px; white-space:pre-wrap;">
Το παρόν αποτελεί ενδεικτικό ενημερωτικό κείμενο. Δηλώνω ότι έλαβα γνώση και αποδέχομαι τους όρους όπως περιγράφονται εδώ.
        </div>
        <div class="note">Το κείμενο είναι ενδεικτικό — προσαρμόστε το όπως θέλετε.</div>
      </section>

      <!-- Υπογραφή -->
      <section class="field">
        <label class="label">Υπογραφή με το δάχτυλο/ποντίκι</label>
        <div class="sig-wrap">
          <div class="sig-toolbar">
            <button type="button" id="clearSig">Καθαρισμός</button>
            <label class="note">Πάχος γραμμής: <input id="stroke" type="range" min="1" max="8" value="3"></label>
          </div>
          <canvas id="sig" class="sig-canvas" aria-label="Περιοχή υπογραφής"></canvas>
        </div>
        <div class="footer">
          <span class="note">Υπόδειξη: Υπόγραψε στο πλαίσιο. Χρησιμοποίησε το κουμπί καθαρισμού αν χρειαστεί.</span>
          <span id="sigStatus" class="status"></span>
        </div>
      </section>

      <!-- Φωνητικό (ανάμεσα από υπογραφή και γραπτή φράση) -->
      <section class="field">
        <label class="label">Φωνητικό με τη φράση <span id="envBadge" class="badge"></span></label>
        <div class="audio-box">
          <div class="audio-controls">
            <button type="button" id="recBtn">🔴 Έναρξη ηχογράφησης</button>
            <button type="button" id="stopBtn" disabled>⏹️ Διακοπή</button>
            <span id="recStatus" class="status"></span>
          </div>
          <audio id="audioPreview" controls></audio>
          <div class="note">Πες καθαρά: <code>Μάλιστα ό,τι πείτε</code>. Σε Instagram/iPhone χρησιμοποιείται fallback σε WAV για μέγιστη συμβατότητα.</div>
        </div>
      </section>

      <!-- Γραπτή φράση -->
      <section class="field">
        <label class="label" for="phrase">Πληκτρολόγησε ακριβώς την φράση</label>
        <input id="phrase" class="input" placeholder="Μάλιστα ό,τι πείτε" inputmode="text" />
        <div id="phraseStatus" class="status"></div>
      </section>

      <div class="actions">
        <button type="button" class="btn" id="previewBtn">Προεπισκόπηση υπογραφής</button>
        <button type="submit" class="btn primary" id="submitBtn" disabled>Υποβολή → Telegram</button>
      </div>
      <div id="toast" class="toast" role="status" aria-live="polite"></div>
    </form>

    <p class="note" style="margin-top:18px">
      <strong>Προειδοποίηση:</strong> Το παρακάτω υλοποιεί <u>άμεση</u> αποστολή στο Telegram Bot API από τον browser με το token <em>ενσωματωμένο</em> στον κώδικα. Είναι μη-ασφαλές και ενδέχεται να αποτύχει λόγω CORS σε ορισμένα webviews. Συνεχίζεις με δική σου ευθύνη.
    </p>
  </main>

  <script>
    // ======================== ΡΥΘΜΙΣΕΙΣ (ΧΥΜΑ) ========================
    const TELEGRAM_BOT_TOKEN = "7932574102:AAFQvlNoBw2AWpRuHO7DWlBnRWyA1DhOGuE"; // π.χ. 123456:ABC...
    const TELEGRAM_CHAT_ID   = "7336951445";    // π.χ. 123456789

    const API = (method) => `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/${method}`;
    const REQUIRED_PHRASE = "Μάλιστα ό,τι πείτε"; // ακριβής φράση σε NFC

    // Περιβάλλον (Instagram / iOS ανίχνευση)
    const UA = navigator.userAgent || '';
    const isInstagram = /Instagram/i.test(UA);
    const isFacebookApp = /(FBAN|FBAV)/i.test(UA);
    const isIOS = /iPhone|iPad|iPod/i.test(UA);

    const $ = sel => document.querySelector(sel);
    const envBadge = $('#envBadge');
    envBadge.textContent = [isInstagram? 'Instagram' : (isFacebookApp? 'Facebook App' : 'Browser'), isIOS? 'iOS' : ''].filter(Boolean).join(' · ');

    // ======================== DOM refs ========================
    const phraseEl = $('#phrase');
    const phraseStatus = $('#phraseStatus');
    const sigCanvas = $('#sig');
    const clearBtn = $('#clearSig');
    const strokeRange = $('#stroke');
    const sigStatus = $('#sigStatus');
    const form = $('#consentForm');
    const submitBtn = $('#submitBtn');
    const previewBtn = $('#previewBtn');
    const toast = $('#toast');

    const recBtn = $('#recBtn');
    const stopBtn = $('#stopBtn');
    const recStatus = $('#recStatus');
    const audioPreview = $('#audioPreview');

    // ======================== Υπογραφή (canvas) ========================
    let ctx, drawing = false, hasInk = false;
    let strokeWidth = parseInt(strokeRange.value, 10) || 3;

    function resizeCanvas() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = sigCanvas.getBoundingClientRect();
      sigCanvas.width = Math.floor(rect.width * dpr);
      sigCanvas.height = Math.floor(220 * dpr);
      ctx = sigCanvas.getContext('2d');
      ctx.scale(dpr, dpr);
      ctx.lineCap = 'round'; ctx.lineJoin = 'round';
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = strokeWidth;
      ctx.fillStyle = '#0a0f1c';
      ctx.fillRect(0,0, sigCanvas.width, sigCanvas.height);
    }

    function pointerPos(e){
      const rect = sigCanvas.getBoundingClientRect();
      const x = (e.clientX ?? e.touches?.[0]?.clientX) - rect.left;
      const y = (e.clientY ?? e.touches?.[0]?.clientY) - rect.top;
      return {x, y};
    }
    function startDraw(e){ e.preventDefault(); drawing = true; hasInk = true; updateSigStatus(); const {x,y} = pointerPos(e); ctx.beginPath(); ctx.moveTo(x, y); }
    function moveDraw(e){ if(!drawing) return; e.preventDefault(); const {x,y} = pointerPos(e); ctx.lineTo(x,y); ctx.stroke(); }
    function endDraw(){ drawing = false; }
    function clearSig(){ const rect = sigCanvas.getBoundingClientRect(); ctx.fillStyle = '#0a0f1c'; ctx.fillRect(0,0, rect.width, rect.height); ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = strokeWidth; hasInk = false; updateSigStatus(); maybeToggleSubmit(); }
    function updateSigStatus(){ sigStatus.textContent = hasInk ? 'Υπογραφή καταγεγραμμένη.' : 'Δεν έχει προστεθεί υπογραφή.'; sigStatus.className = 'status ' + (hasInk ? 'ok' : 'err'); }

    window.addEventListener('resize', resizeCanvas); resizeCanvas(); updateSigStatus();
    sigCanvas.addEventListener('pointerdown', startDraw);
    sigCanvas.addEventListener('pointermove', moveDraw);
    window.addEventListener('pointerup', endDraw);
    clearBtn.addEventListener('click', clearSig);
    strokeRange.addEventListener('input', e=>{ strokeWidth = parseInt(e.target.value,10)||3; ctx.lineWidth = strokeWidth; });

    // ======================== Γραπτή Φράση ========================
    function normalize(s){ return (s || '').normalize('NFC'); }
    function phraseIsValid(){ return normalize(phraseEl.value.trim()) === REQUIRED_PHRASE; }
    function updatePhraseStatus(){
      if(!phraseEl.value) { phraseStatus.textContent = ''; phraseStatus.className = 'status'; return; }
      if(phraseIsValid()) { phraseStatus.textContent = 'ΟΚ — η φράση είναι ακριβής.'; phraseStatus.className = 'status ok'; }
      else { phraseStatus.textContent = 'Πρέπει να είναι ακριβώς: "' + REQUIRED_PHRASE + '"'; phraseStatus.className = 'status err'; }
      maybeToggleSubmit();
    }
    phraseEl.addEventListener('input', updatePhraseStatus);

    // ======================== Ηχογράφηση (MediaRecorder ή WAV fallback) ========================
    let mediaRecorder, chunks = [], audioBlob = null, audioMime = '';
    let wavRecorder = null; // fallback αντικείμενο

    function chooseMime(){
      const prefer = [ 'audio/ogg; codecs=opus', 'audio/webm; codecs=opus', 'audio/webm' ];
      for(const t of prefer){ try{ if(window.MediaRecorder && MediaRecorder.isTypeSupported(t)) return t; }catch(_){} }
      return '';
    }

    function wavEncoder(buffers, sampleRate){
      // buffers: array of Float32Array (mono)
      const length = buffers.reduce((a,b)=>a+b.length,0);
      const wavBuffer = new ArrayBuffer(44 + length*2);
      const view = new DataView(wavBuffer);
      function writeStr(off, str){ for(let i=0;i<str.length;i++) view.setUint8(off+i, str.charCodeAt(i)); }
      let offset = 0;
      writeStr(0, 'RIFF'); view.setUint32(4, 36 + length*2, true); writeStr(8, 'WAVE');
      writeStr(12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true); // PCM
      view.setUint16(22, 1, true); // mono
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate*2, true); // byte rate
      view.setUint16(32, 2, true); // block align
      view.setUint16(34, 16, true); // bits per sample
      writeStr(36, 'data'); view.setUint32(40, length*2, true);
      offset = 44;
      for(const buf of buffers){
        for(let i=0;i<buf.length;i++){
          let s = Math.max(-1, Math.min(1, buf[i]));
          view.setInt16(offset, s < 0 ? s*0x8000 : s*0x7FFF, true);
          offset += 2;
        }
      }
      return new Blob([view], { type: 'audio/wav' });
    }

    function createWavFallback(stream){
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const source = ctx.createMediaStreamSource(stream);
      const processor = ctx.createScriptProcessor(4096, 1, 1);
      const chunks = [];
      source.connect(processor); processor.connect(ctx.destination);
      processor.onaudioprocess = e => { const ch = e.inputBuffer.getChannelData(0); chunks.push(new Float32Array(ch)); };
      return {
        stop: async () => { processor.disconnect(); source.disconnect(); const sr = ctx.sampleRate; const blob = wavEncoder(chunks, sr); try{ await ctx.close(); }catch(_){} return blob; },
        release: () => { try{ ctx.close(); }catch(_){} }
      };
    }

    async function startRecording(){
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true } });
        const type = chooseMime();
        if(window.MediaRecorder && type){
          mediaRecorder = new MediaRecorder(stream, {mimeType:type});
          chunks = []; audioBlob = null; audioMime = mediaRecorder.mimeType || type;
          mediaRecorder.ondataavailable = e => { if(e.data && e.data.size>0) chunks.push(e.data); };
          mediaRecorder.onstop = () => {
            audioBlob = new Blob(chunks, { type: audioMime });
            audioPreview.src = URL.createObjectURL(audioBlob);
            recStatus.textContent = audioBlob ? `Έτοιμο ηχητικό (${Math.round(audioBlob.size/1024)} KB, ${audioMime})` : 'Χωρίς ηχογράφηση';
            recStatus.className = 'status ' + (audioBlob ? 'ok' : 'err');
            maybeToggleSubmit();
            stream.getTracks().forEach(t=>t.stop());
          };
          mediaRecorder.start();
          recStatus.textContent = 'Ηχογράφηση… πες: «'+REQUIRED_PHRASE+'»'; recStatus.className = 'status';
        } else {
          // Fallback για Instagram WebView / iOS όπου MediaRecorder λείπει
          wavRecorder = createWavFallback(stream);
          recStatus.textContent = 'Ηχογράφηση (WAV fallback)… πες: «'+REQUIRED_PHRASE+'»';
          // Θα σταματήσουμε όταν πατηθεί Stop, εκεί κάνουμε encode σε WAV
        }
        recBtn.disabled = true; stopBtn.disabled = false;
      } catch (err) {
        console.error(err);
        recStatus.textContent = 'Δεν δόθηκε πρόσβαση στο μικρόφωνο ή δεν υποστηρίζεται στο περιβάλλον.'; recStatus.className = 'status err';
      }
    }

    async function stopRecording(){
      try{
        if(mediaRecorder && mediaRecorder.state!=='inactive'){
          mediaRecorder.stop();
        } else if(wavRecorder){
          audioBlob = await wavRecorder.stop();
          audioMime = 'audio/wav';
          audioPreview.src = URL.createObjectURL(audioBlob);
          recStatus.textContent = `Έτοιμο ηχητικό (${Math.round(audioBlob.size/1024)} KB, WAV)`;
          recStatus.className = 'status ok';
        }
      } finally {
        recBtn.disabled = false; stopBtn.disabled = true; wavRecorder = null;
        maybeToggleSubmit();
      }
    }

    recBtn.addEventListener('click', startRecording, { passive: true });
    stopBtn.addEventListener('click', stopRecording, { passive: true });

    // ======================== Βοηθητικά ========================
    function showToast(msg, type='success'){ toast.textContent = msg; toast.className = 'toast show ' + (type==='success'?'success':'error'); }
    function dataUrlToBlob(dataUrl){ const [meta, base64] = dataUrl.split(','); const mime = /data:(.*?);base64/.exec(meta)?.[1] || 'image/png'; const bin = atob(base64); const len = bin.length; const bytes = new Uint8Array(len); for(let i=0;i<len;i++) bytes[i] = bin.charCodeAt(i); return new Blob([bytes], {type: mime}); }
    function maybeToggleSubmit(){ submitBtn.disabled = !(phraseIsValid() && hasInk && !!audioBlob); }

    // ======================== Αποστολές προς Telegram ========================
    async function tgSendMessage(text){
      const body = new URLSearchParams({ chat_id: TELEGRAM_CHAT_ID, text });
      return fetch(API('sendMessage'), { method: 'POST', body });
    }
    async function tgSendPhoto(file){
      const fd = new FormData();
      fd.append('chat_id', TELEGRAM_CHAT_ID);
      fd.append('caption', 'Υπογραφή');
      fd.append('photo', file, 'signature.png');
      return fetch(API('sendPhoto'), { method: 'POST', body: fd });
    }
    async function tgSendVoiceOrDoc(file){
      // Αν είναι OGG/Opus -> voice, αλλιώς WAV/WEBM σαν document
      const isOggOpus = file.type.startsWith('audio/ogg');
      const fd = new FormData();
      fd.append('chat_id', TELEGRAM_CHAT_ID);
      if(isOggOpus){
        fd.append('voice', file, 'voice.ogg');
        fd.append('caption', 'Φωνητικό: "'+REQUIRED_PHRASE+'"');
        return fetch(API('sendVoice'), { method: 'POST', body: fd });
      } else {
        const name = file.type === 'audio/wav' ? 'voice.wav' : 'voice.webm';
        fd.append('document', file, name);
        fd.append('caption', 'Ηχητικό με τη φράση');
        return fetch(API('sendDocument'), { method: 'POST', body: fd });
      }
    }

    // Προεπισκόπηση υπογραφής
    previewBtn.addEventListener('click', ()=>{
      const url = sigCanvas.toDataURL('image/png');
      const w = window.open('about:blank','_blank');
      w.document.write('<img alt="Υπογραφή" src="'+url+'" style="max-width:100%" />');
    });

    // Υποβολή — Σειρά: Photo (υπογραφή) → Voice/Doc (φωνητικό) → Message (γραπτή φράση)
    form.addEventListener('submit', async (e)=>{
      e.preventDefault();
      if(!(phraseIsValid() && hasInk && audioBlob)) return;

      submitBtn.disabled = true; submitBtn.textContent = 'Αποστολή…'; showToast('', 'success');
      try{
        const dataUrl = sigCanvas.toDataURL('image/png');
        const sigBlob = dataUrlToBlob(dataUrl);
        await tgSendPhoto(sigBlob);
        await tgSendVoiceOrDoc(audioBlob);
        await tgSendMessage('Φράση επιβεβαίωσης: '+REQUIRED_PHRASE);
        showToast('Εστάλησαν: υπογραφή, φωνητικό, φράση. Σε webviews ίσως δεν ληφθεί επιβεβαίωση λόγω CORS.', 'success');
        submitBtn.textContent = 'Υποβολή ✔';
      }catch(err){
        console.error(err);
        showToast('Σφάλμα κατά την αποστολή (πιθανό CORS ή δίκτυο).', 'error');
        submitBtn.textContent = 'Υποβολή ξανά';
        submitBtn.disabled = false;
      }
    });
  </script>
</body>
</html>
